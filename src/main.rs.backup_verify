use axum::{
    extract::{ws::{Message, WebSocket, WebSocketUpgrade}, State},
    response::{Html, IntoResponse, Json},
    routing::{get, post},
    Router,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_json::json;
use sha2::{Digest, Sha256};
use std::{
    collections::HashMap,
    fs,
    path::Path,
    process::{Command, Stdio},
    sync::Arc,
    time::Instant,
};
use tokio::sync::{Mutex, broadcast};
use tower_http::{cors::CorsLayer, services::ServeDir};
use tracing::{error, info, warn};
use uuid::Uuid;
use futures_util::{StreamExt, SinkExt};

// Constants for persistence
const PROOFS_DB_FILE: &str = "./proofs_db.json";
const VERIFICATIONS_DB_FILE: &str = "./verifications_db.json";

#[derive(Clone)]
struct AppState {
    zkengine_binary: String,
    wasm_dir: String,
    proofs_dir: String,
    proof_store: Arc<Mutex<HashMap<String, ProofRecord>>>,
    verification_store: Arc<Mutex<Vec<VerificationRecord>>>,
    tx: broadcast::Sender<WsMessage>,
    langchain_url: String,
    session_store: Arc<Mutex<HashMap<String, String>>>,
}

#[derive(Serialize, Deserialize, Clone)]
struct ProofRecord {
    id: String,
    timestamp: DateTime<Utc>,
    metadata: ProofMetadata,
    metrics: ProofMetrics,
    status: ProofStatus,
    file_path: Option<String>,
}

#[derive(Serialize, Deserialize, Clone)]
struct VerificationRecord {
    id: String,
    proof_id: String,
    timestamp: DateTime<Utc>,
    is_valid: bool,
    verification_time_secs: f64,
    error: Option<String>,
}

#[derive(Serialize, Deserialize, Clone)]
struct ProofMetadata {
    wasm_path: String,
    function: String,
    arguments: Vec<String>,
    step_size: u64,
}

#[derive(Serialize, Deserialize, Clone)]
struct ProofMetrics {
    generation_time_secs: f64,
    file_size_mb: f64,
    file_hash: String,
    peak_memory_mb: Option<f64>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(rename_all = "lowercase")]
enum ProofStatus {
    Pending,
    Running,
    Complete,
    Failed(String),
}

#[derive(Serialize, Clone)]
struct WsMessage {
    #[serde(rename = "type")]
    msg_type: String,
    content: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    data: Option<serde_json::Value>,
}

#[derive(Deserialize)]
struct ChatMessage {
    message: String,
}

// LangChain service integration
#[derive(Debug, Serialize, Deserialize)]
struct LangChainRequest {
    message: String,
    session_id: Option<String>,
    context: Option<serde_json::Value>,
}

#[derive(Debug, Serialize, Deserialize)]
struct LangChainResponse {
    intent: Option<LangChainIntent>,
    response: String,
    session_id: String,
    requires_proof: bool,
}

#[derive(Debug, Serialize, Deserialize)]
struct LangChainIntent {
    function: String,
    arguments: Vec<String>,
    step_size: u64,
    explanation: String,
    complexity_reasoning: Option<String>,
}

// Persistence functions
async fn save_proofs_to_disk(proofs: &HashMap<String, ProofRecord>) -> Result<(), Box<dyn std::error::Error>> {
    let json = serde_json::to_string_pretty(proofs)?;
    tokio::fs::write(PROOFS_DB_FILE, json).await?;
    Ok(())
}

async fn load_proofs_from_disk() -> Result<HashMap<String, ProofRecord>, Box<dyn std::error::Error>> {
    if Path::new(PROOFS_DB_FILE).exists() {
        let json = tokio::fs::read_to_string(PROOFS_DB_FILE).await?;
        let proofs: HashMap<String, ProofRecord> = serde_json::from_str(&json)?;
        Ok(proofs)
    } else {
        Ok(HashMap::new())
    }
}

async fn save_verifications_to_disk(verifications: &Vec<VerificationRecord>) -> Result<(), Box<dyn std::error::Error>> {
    let json = serde_json::to_string_pretty(verifications)?;
    tokio::fs::write(VERIFICATIONS_DB_FILE, json).await?;
    Ok(())
}

async fn load_verifications_from_disk() -> Result<Vec<VerificationRecord>, Box<dyn std::error::Error>> {
    if Path::new(VERIFICATIONS_DB_FILE).exists() {
        let json = tokio::fs::read_to_string(VERIFICATIONS_DB_FILE).await?;
        let verifications: Vec<VerificationRecord> = serde_json::from_str(&json)?;
        Ok(verifications)
    } else {
        Ok(Vec::new())
    }
}

#[tokio::main]
async fn main() {
    dotenv::dotenv().ok();
    tracing_subscriber::fmt::init();

    let zkengine_binary = std::env::var("ZKENGINE_BINARY")
        .unwrap_or_else(|_| "/usr/local/bin/zkengine".to_string());
    let wasm_dir = std::env::var("WASM_DIR")
        .unwrap_or_else(|_| "./zkengine_data/wasm".to_string());
    let proofs_dir = std::env::var("PROOFS_DIR")
        .unwrap_or_else(|_| "./proofs".to_string());
    let port = std::env::var("PORT")
        .unwrap_or_else(|_| "8001".to_string())
        .parse::<u16>()
        .unwrap_or(8001);
    let langchain_url = std::env::var("LANGCHAIN_SERVICE_URL")
        .unwrap_or_else(|_| "http://localhost:8002".to_string());

    // Create directories
    fs::create_dir_all(&proofs_dir).ok();

    // Create broadcast channel for WebSocket messages
    let (tx, _rx) = broadcast::channel::<WsMessage>(1000);

    // Load existing proofs and verifications
    let stored_proofs = load_proofs_from_disk().await.unwrap_or_else(|e| {
        warn!("Failed to load proofs from disk: {}", e);
        HashMap::new()
    });
    
    let stored_verifications = load_verifications_from_disk().await.unwrap_or_else(|e| {
        warn!("Failed to load verifications from disk: {}", e);
        Vec::new()
    });

    info!("Loaded {} proofs and {} verifications from disk", 
          stored_proofs.len(), stored_verifications.len());

    let state = AppState {
        zkengine_binary,
        wasm_dir,
        proofs_dir,
        proof_store: Arc::new(Mutex::new(stored_proofs)),
        verification_store: Arc::new(Mutex::new(stored_verifications)),
        tx: tx.clone(),
        langchain_url,
        session_store: Arc::new(Mutex::new(HashMap::new())),
    };

    let app = Router::new()
        .route("/", get(serve_index))
        .route("/ws", get(websocket_handler))
        .route("/api/health", get(health_check))
        .route("/api/langchain/health", get(langchain_health))
        .route("/api/proofs", get(list_proofs))
        .route("/api/proofs/:id", get(get_proof))
        .route("/api/proofs/generate", post(generate_proof))
        .route("/api/cleanup", post(cleanup_old_proofs))
        .nest_service("/static", ServeDir::new("static"))
        .layer(CorsLayer::permissive())
        .with_state(state);

    let addr = format!("0.0.0.0:{}", port);
    info!("🚀 zkEngine Agent Kit running on http://{}", addr);
    
    axum::Server::bind(&addr.parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn serve_index() -> impl IntoResponse {
    Html(include_str!("../static/index.html"))
}

async fn health_check(State(state): State<AppState>) -> impl IntoResponse {
    let binary_exists = Path::new(&state.zkengine_binary).exists();
    let wasm_dir_exists = Path::new(&state.wasm_dir).exists();
    
    Json(json!({
        "status": "ok",
        "zkengine_binary": state.zkengine_binary,
        "binary_exists": binary_exists,
        "wasm_dir": state.wasm_dir,
        "wasm_dir_exists": wasm_dir_exists,
        "proofs_dir": state.proofs_dir,
        "langchain_url": state.langchain_url,
    }))
}

async fn langchain_health(State(state): State<AppState>) -> impl IntoResponse {
    let client = reqwest::Client::new();
    match client.get(&format!("{}/health", state.langchain_url)).send().await {
        Ok(response) => {
            if response.status().is_success() {
                let health_data: serde_json::Value = response.json().await.unwrap_or_default();
                Json(json!({
                    "langchain_service": "healthy",
                    "details": health_data
                }))
            } else {
                Json(json!({
                    "langchain_service": "unhealthy",
                    "error": "Service returned non-200 status"
                }))
            }
        },
        Err(e) => Json(json!({
            "langchain_service": "unreachable",
            "error": e.to_string()
        }))
    }
}

async fn list_proofs(State(state): State<AppState>) -> impl IntoResponse {
    let proofs = state.proof_store.lock().await;
    let proofs_list: Vec<&ProofRecord> = proofs.values().collect();
    Json(json!({
        "proofs": proofs_list,
        "count": proofs_list.len()
    }))
}

async fn get_proof(
    State(state): State<AppState>,
    axum::extract::Path(id): axum::extract::Path<String>,
) -> impl IntoResponse {
    let proofs = state.proof_store.lock().await;
    match proofs.get(&id) {
        Some(proof) => Json(json!({
            "success": true,
            "proof": proof
        })),
        None => Json(json!({
            "success": false,
            "error": "Proof not found"
        }))
    }
}

async fn generate_proof(
    State(state): State<AppState>,
    Json(request): Json<serde_json::Value>,
) -> impl IntoResponse {
    let proof_id = Uuid::new_v4().to_string();
    
    // Parse request
    let wasm_file = request["wasm_file"].as_str().unwrap_or("fibonacci.wat");
    let function = request["function"].as_str().unwrap_or("main");
    let args = request["arguments"].as_array()
        .map(|arr| arr.iter()
            .filter_map(|v| v.as_str().map(String::from))
            .collect::<Vec<_>>())
        .unwrap_or_default();
    let step_size = request["step_size"].as_u64().unwrap_or(50);
    
    let metadata = ProofMetadata {
        wasm_path: format!("{}/{}", state.wasm_dir, wasm_file),
        function: function.to_string(),
        arguments: args.clone(),
        step_size,
    };
    
    // Create proof record
    let proof_record = ProofRecord {
        id: proof_id.clone(),
        timestamp: Utc::now(),
        metadata: metadata.clone(),
        metrics: ProofMetrics {
            generation_time_secs: 0.0,
            file_size_mb: 0.0,
            file_hash: String::new(),
            peak_memory_mb: None,
        },
        status: ProofStatus::Pending,
        file_path: None,
    };
    
    state.proof_store.lock().await.insert(proof_id.clone(), proof_record.clone());
    
    // Save to disk
    {
        let proofs = state.proof_store.lock().await;
        if let Err(e) = save_proofs_to_disk(&*proofs).await {
            error!("Failed to save proofs to disk: {}", e);
        }
    }
    
    // Spawn proof generation
    let state_clone = state.clone();
    let proof_id_clone = proof_id.clone();
    tokio::spawn(async move {
        generate_real_proof(state_clone, proof_id_clone, metadata, args).await;
    });
    
    Json(json!({
        "success": true,
        "proof_id": proof_id,
        "message": "Proof generation started"
    }))
}

async fn cleanup_old_proofs(State(state): State<AppState>) -> impl IntoResponse {
    let mut proofs = state.proof_store.lock().await;
    let cutoff = Utc::now() - chrono::Duration::days(7); // Keep last 7 days
    
    let before_count = proofs.len();
    proofs.retain(|_, proof| proof.timestamp > cutoff);
    let after_count = proofs.len();
    
    if let Err(e) = save_proofs_to_disk(&*proofs).await {
        error!("Failed to save proofs after cleanup: {}", e);
    }
    
    Json(json!({
        "message": "Cleaned up old proofs",
        "removed": before_count - after_count,
        "remaining": after_count
    }))
}

async fn websocket_handler(
    ws: WebSocketUpgrade,
    State(state): State<AppState>,
) -> impl IntoResponse {
    ws.on_upgrade(move |socket| websocket_connection(socket, state))
}

async fn websocket_connection(socket: WebSocket, state: AppState) {
    let (mut sender, mut receiver) = socket.split();
    
    // Subscribe to broadcast channel
    let mut rx = state.tx.subscribe();
    
    // Send welcome message
    let welcome = WsMessage {
        msg_type: "message".to_string(),
        content: "Connected to zkEngine Agent Kit! Try 'prove fibonacci of 20' or 'help'.".to_string(),
        data: None,
    };
    sender.send(Message::Text(serde_json::to_string(&welcome).unwrap())).await.ok();
    
    // Spawn task to receive broadcast messages
    let send_task = tokio::spawn(async move {
        while let Ok(msg) = rx.recv().await {
            if sender.send(Message::Text(serde_json::to_string(&msg).unwrap())).await.is_err() {
                break;
            }
        }
    });
    
    while let Some(msg) = receiver.next().await {
        if let Ok(msg) = msg {
            match msg {
                Message::Text(text) => {
                    if let Ok(chat_msg) = serde_json::from_str::<ChatMessage>(&text) {
                        let response = process_nl_command(&state, &chat_msg.message).await;
                        // Only send a message if there's content
                        if !response.message.is_empty() {
                            let ws_msg = WsMessage {
                                msg_type: "message".to_string(),
                                content: response.message,
                                data: response.data,
                            };
                            // Broadcast to all clients
                            let _ = state.tx.send(ws_msg);
                        } else if let Some(data) = response.data {
                            // Send data-only message if no text content
                            let ws_msg = WsMessage {
                                msg_type: "message".to_string(),
                                content: String::new(),
                                data: Some(data),
                            };
                            let _ = state.tx.send(ws_msg);
                        }
                    }
                }
                Message::Close(_) => break,
                _ => {}
            }
        }
    }
    
    send_task.abort();
}

struct NlResponse {
    message: String,
    data: Option<serde_json::Value>,
}

// Add LangChain processing function
async fn process_with_langchain(
    langchain_url: &str, 
    message: &str, 
    session_id: Option<String>
) -> Result<LangChainResponse, anyhow::Error> {
    let client = reqwest::Client::new();
    
    let request = LangChainRequest {
        message: message.to_string(),
        session_id,
        context: None,
    };
    
    let response = client
        .post(&format!("{}/chat", langchain_url))
        .json(&request)
        .timeout(std::time::Duration::from_secs(30))
        .send()
        .await?;
    
    if !response.status().is_success() {
        let error_text = response.text().await?;
        return Err(anyhow::anyhow!("LangChain service error: {}", error_text));
    }
    
    let langchain_response: LangChainResponse = response.json().await?;
    Ok(langchain_response)
}

async fn process_nl_command(state: &AppState, input: &str) -> NlResponse {
    let input_lower = input.to_lowercase();
    
    // Get or create session ID for this connection
    let session_id = Some("default".to_string());
    
    // First, ALWAYS try LangChain for ANY input to get natural language processing
    match process_with_langchain(&state.langchain_url, input, session_id.clone()).await {
        Ok(langchain_response) => {
            // ALWAYS send the natural language response first if it exists
            if !langchain_response.response.is_empty() {
                let nl_msg = WsMessage {
                    msg_type: "message".to_string(),
                    content: langchain_response.response.clone(),
                    data: Some(json!({ 
                        "session_id": langchain_response.session_id,
                        "from_langchain": true 
                    })),
                };
                // Send the natural language response immediately
                let _ = state.tx.send(nl_msg);
            }
            
            // Now handle the actual command execution
            // Check for verification
            if input_lower.contains("verify") {
                if let Some(id) = extract_proof_id(&input_lower) {
                    return verify_proof_command(state, id).await;
                }
                
                // Verify last proof
                let last_proof_id = {
                    let proofs = state.proof_store.lock().await;
                    proofs.values()
                        .max_by_key(|p| p.timestamp)
                        .map(|p| p.id.clone())
                };
                
                if let Some(proof_id) = last_proof_id {
                    return verify_proof_command(state, &proof_id).await;
                }
                
                return NlResponse {
                    message: String::new(), // Already sent via LangChain
                    data: Some(json!({
                        "error": "No proofs to verify"
                    })),
                };
            }
            
            // Check for list proofs
            if input_lower.contains("list") && input_lower.contains("proof") && !input_lower.contains("verif") {
                let proofs = state.proof_store.lock().await;
                if proofs.is_empty() {
                    return NlResponse {
                        message: String::new(), // Already sent response
                        data: Some(json!({
                            "type": "proof_list",
                            "proofs": [],
                            "count": 0
                        })),
                    };
                }
                
                let proofs_vec: Vec<ProofRecord> = proofs.values().cloned().collect();
                return NlResponse {
                    message: String::new(),
                    data: Some(json!({
                        "type": "proof_list",
                        "proofs": proofs_vec,
                        "count": proofs_vec.len()
                    })),
                };
            }
            
            // Check for list verifications
            if input_lower.contains("list") && input_lower.contains("verif") {
                let verifications = state.verification_store.lock().await;
                return NlResponse {
                    message: String::new(),
                    data: Some(json!({
                        "type": "verification_list",
                        "verifications": verifications.clone(),
                        "count": verifications.len()
                    })),
                };
            }
            
            // Check for status
            if input_lower.contains("status") {
                let binary_exists = Path::new(&state.zkengine_binary).exists();
                let wasm_count = fs::read_dir(&state.wasm_dir)
                    .map(|entries| entries.filter_map(Result::ok).count())
                    .unwrap_or(0);
                
                // Send status data as structured response
                return NlResponse {
                    message: String::new(), // Natural language already sent
                    data: Some(json!({
                        "type": "status",
                        "zkengine_binary_exists": binary_exists,
                        "wasm_files": wasm_count,
                        "proofs_generated": state.proof_store.lock().await.len(),
                        "verifications_performed": state.verification_store.lock().await.len(),
                    })),
                };
            }
            
            // Check for get proof
            if input_lower.contains("get proof") {
                if let Some(id) = extract_proof_id(&input_lower) {
                    let proofs = state.proof_store.lock().await;
                    if let Some(proof) = proofs.values().find(|p| p.id.starts_with(id)) {
                        return NlResponse {
                            message: String::new(), // Natural language already sent
                            data: Some(json!({
                                "type": "proof_details",
                                "proof": proof
                            })),
                        };
                    }
                }
                return NlResponse {
                    message: String::new(),
                    data: Some(json!({
                        "error": "Proof not found"
                    })),
                };
            }
            
            // Check for proof generation
            if langchain_response.requires_proof && langchain_response.intent.is_some() {
                let intent = langchain_response.intent.unwrap();
                
                // Map function name to WASM file
                let wasm_file = match intent.function.as_str() {
                    "fibonacci" => "fib.wat",
                    "add" => "add.wat",
                    "multiply" => "multiply.wat",
                    "factorial" => "factorial_i32.wat",
                    "is_even" => "is_even.wat",
                    "square" => "square.wat",
                    "max" => "max.wat",
                    "count_until" => "count_until.wat",
                    _ => {
                        return NlResponse {
                            message: String::new(), // Error will be in data
                            data: Some(json!({
                                "error": format!("Unknown function: {}", intent.function)
                            })),
                        };
                    }
                };
                
                let proof_id = Uuid::new_v4().to_string();
                let metadata = ProofMetadata {
                    wasm_path: format!("{}/{}", state.wasm_dir, wasm_file),
                    function: "main".to_string(),
                    arguments: intent.arguments.clone(),
                    step_size: intent.step_size,
                };
                
                // Create proof record
                let proof_record = ProofRecord {
                    id: proof_id.clone(),
                    timestamp: Utc::now(),
                    metadata: metadata.clone(),
                    metrics: ProofMetrics {
                        generation_time_secs: 0.0,
                        file_size_mb: 0.0,
                        file_hash: String::new(),
                        peak_memory_mb: None,
                    },
                    status: ProofStatus::Pending,
                    file_path: None,
                };
                
                state.proof_store.lock().await.insert(proof_id.clone(), proof_record);
                
                // Save to disk
                {
                    let proofs = state.proof_store.lock().await;
                    if let Err(e) = save_proofs_to_disk(&*proofs).await {
                        error!("Failed to save proofs to disk: {}", e);
                    }
                }
                
                // Spawn proof generation
                let state_clone = state.clone();
                let proof_id_clone = proof_id.clone();
                let args = intent.arguments.clone();
                tokio::spawn(async move {
                    generate_real_proof(state_clone, proof_id_clone, metadata, args).await;
                });
                
                // Send proof starting notification
                let announce_msg = WsMessage {
                    msg_type: "message".to_string(),
                    content: format!(
                        "🔧 Starting proof generation:\n\
                         • Function: {}\n\
                         • Arguments: {:?}\n\
                         • WASM: {}\n\
                         • Steps: {}\n\
                         • Proof ID: {}...",
                        intent.function,
                        intent.arguments,
                        wasm_file,
                        intent.step_size,
                        &proof_id[..8]
                    ),
                    data: Some(json!({ 
                        "proof_id": proof_id,
                        "starting_proof": true
                    })),
                };
                let _ = state.tx.send(announce_msg);
                
                return NlResponse {
                    message: String::new(), // All messages sent via broadcast
                    data: None,
                };
            }
            
            // Just conversation - response already sent
            return NlResponse {
                message: String::new(),
                data: None,
            };
        },
        Err(e) => {
            warn!("LangChain processing failed: {}", e);
            // Fall back to local command processing
        }
    }
    
    // Fallback for when LangChain is unavailable
    // Help command
    if input_lower.contains("help") {
        return NlResponse {
            message: "🤖 zkEngine Agent Kit Commands:\n\n\
                     • prove fibonacci of N - Generate a Fibonacci proof\n\
                     • prove add X and Y - Prove addition\n\
                     • prove multiply X by Y - Prove multiplication\n\
                     • list all proofs - Show all generated proofs\n\
                     • list verifications - Show verification history\n\
                     • get proof <id> - Get specific proof details\n\
                     • verify - Verify last proof\n\
                     • verify proof <id> - Verify specific proof\n\
                     • status - Check system status\n\
                     • help - Show this message\n\n\
                     💡 Pro tip: I understand natural language! Try:\n\
                     • 'What's the 20th fibonacci number?'\n\
                     • 'Show me that 42 is even'\n\
                     • 'Calculate 15 times 8 and prove it'".to_string(),
            data: None,
        };
    }
    
    // If we get here, LangChain failed and we don't recognize the command
    NlResponse {
        message: "I didn't understand that. Try 'help' for available commands or check if the AI service is running.".to_string(),
        data: None,
    }
}

async fn handle_prove_command(state: &AppState, input: &str) -> NlResponse {
    let proof_id = Uuid::new_v4().to_string();
    
    // Parse the prove command
    let (wasm_file, function, args, step_size) = parse_prove_command(input);
    
    let metadata = ProofMetadata {
        wasm_path: format!("{}/{}", state.wasm_dir, wasm_file),
        function: function.clone(),
        arguments: args.clone(),
        step_size,
    };
    
    // Announce what we're doing
    let announce_msg = format!(
        "🔧 Starting proof generation:\n\
         • Function: {}\n\
         • Arguments: {:?}\n\
         • WASM: {}\n\
         • Steps: {}\n\
         • Proof ID: {}...\n\n\
         ⏳ This will take 10-30 seconds...",
        function, args, wasm_file, step_size, &proof_id[..8]
    );
    
    // Create initial proof record
    let proof_record = ProofRecord {
        id: proof_id.clone(),
        timestamp: Utc::now(),
        metadata: metadata.clone(),
        metrics: ProofMetrics {
            generation_time_secs: 0.0,
            file_size_mb: 0.0,
            file_hash: String::new(),
            peak_memory_mb: None,
        },
        status: ProofStatus::Pending,
        file_path: None,
    };
    
    state.proof_store.lock().await.insert(proof_id.clone(), proof_record);
    
    // Save to disk
    {
        let proofs = state.proof_store.lock().await;
        if let Err(e) = save_proofs_to_disk(&*proofs).await {
            error!("Failed to save proofs to disk: {}", e);
        }
    }
    
    // Spawn the actual proof generation
    let state_clone = state.clone();
    let proof_id_clone = proof_id.clone();
    tokio::spawn(async move {
        generate_real_proof(state_clone, proof_id_clone, metadata, args).await;
    });
    
    NlResponse {
        message: announce_msg,
        data: Some(json!({ "proof_id": proof_id })),
    }
}

fn parse_prove_command(input: &str) -> (String, String, Vec<String>, u64) {
    let input_lower = input.to_lowercase();
    
    // Fibonacci
    if input_lower.contains("fibonacci") || input_lower.contains("fib") {
        let n = extract_number(&input_lower).unwrap_or(10);
        let step_size = if n > 15 { 100 } else { 50 };
        return ("fib.wat".to_string(), "main".to_string(), vec![n.to_string()], step_size);
    }
    
    // Addition
    if input_lower.contains("add") || input_lower.contains("sum") {
        let numbers = extract_two_numbers(&input_lower);
        return ("add.wat".to_string(), "main".to_string(), 
                vec![numbers.0.to_string(), numbers.1.to_string()], 50);
    }
    
    // Multiplication
    if input_lower.contains("multiply") || input_lower.contains("times") {
        let numbers = extract_two_numbers(&input_lower);
        return ("multiply.wat".to_string(), "main".to_string(), 
                vec![numbers.0.to_string(), numbers.1.to_string()], 50);
    }
    
    // Factorial
    if input_lower.contains("factorial") {
        let n = extract_number(&input_lower).unwrap_or(5);
        return ("factorial_i32.wat".to_string(), "main".to_string(), vec![n.to_string()], 50);
    }
    
    // Even/odd check
    if input_lower.contains("even") || input_lower.contains("odd") {
        let n = extract_number(&input_lower).unwrap_or(42);
        return ("is_even.wat".to_string(), "main".to_string(), vec![n.to_string()], 50);
    }
    
    // Square
    if input_lower.contains("square") {
        let n = extract_number(&input_lower).unwrap_or(9);
        return ("square.wat".to_string(), "main".to_string(), vec![n.to_string()], 50);
    }
    
    // Max
    if input_lower.contains("max") {
        let numbers = extract_two_numbers(&input_lower);
        return ("max.wat".to_string(), "main".to_string(), 
                vec![numbers.0.to_string(), numbers.1.to_string()], 50);
    }
    
    // Count until
    if input_lower.contains("count") {
        let n = extract_number(&input_lower).unwrap_or(10);
        return ("count_until.wat".to_string(), "main".to_string(), vec![n.to_string()], 50);
    }
    
    // Default
    ("fib.wat".to_string(), "main".to_string(), vec!["10".to_string()], 50)
}

fn extract_number(input: &str) -> Option<u32> {
    input.split_whitespace()
        .find_map(|word| word.parse::<u32>().ok())
}

fn extract_two_numbers(input: &str) -> (u32, u32) {
    let numbers: Vec<u32> = input.split_whitespace()
        .filter_map(|word| word.parse::<u32>().ok())
        .collect();
    
    match numbers.len() {
        0 => (5, 3),
        1 => (numbers[0], 2),
        _ => (numbers[0], numbers[1]),
    }
}

fn extract_proof_id(input: &str) -> Option<&str> {
    // Look for UUID-like patterns or short IDs
    input.split_whitespace()
        .find(|word| word.len() >= 8 && word.chars().all(|c| c.is_alphanumeric() || c == '-'))
}

async fn generate_real_proof(
    state: AppState,
    proof_id: String,
    metadata: ProofMetadata,
    args: Vec<String>,
) {
    let start_time = Instant::now();
    
    // Update status to running
    {
        let mut proofs = state.proof_store.lock().await;
        if let Some(proof) = proofs.get_mut(&proof_id) {
            proof.status = ProofStatus::Running;
        }
        // Save to disk
        if let Err(e) = save_proofs_to_disk(&*proofs).await {
            error!("Failed to save proofs to disk: {}", e);
        }
    }
    
    // Send WebSocket update
    let _ = state.tx.send(WsMessage {
        msg_type: "proof_update".to_string(),
        content: format!("🏃 Generating proof {}...", &proof_id[..8]),
        data: Some(json!({ "proof_id": proof_id, "status": "running" })),
    });
    
    // Create proof directory
    let proof_dir = format!("{}/{}", state.proofs_dir, proof_id);
    fs::create_dir_all(&proof_dir).ok();
    
    // Check if WASM file exists
    if !Path::new(&metadata.wasm_path).exists() {
        error!("WASM file not found: {}", metadata.wasm_path);
        update_proof_failed(&state, &proof_id, "WASM file not found").await;
        return;
    }
    
    // Clone values needed inside the closure
    let zkengine_binary = state.zkengine_binary.clone();
    let wasm_path = metadata.wasm_path.clone();
    let step_size = metadata.step_size;
    let proof_dir_clone = proof_dir.clone();
    let args_vec: Vec<String> = args.clone();
    
    info!("Running zkEngine command for proof {}", proof_id);
    
    match tokio::task::spawn_blocking(move || {
        let mut cmd = Command::new(&zkengine_binary);
        cmd.arg("prove")
            .arg("--wasm").arg(&wasm_path)
            .arg("--step").arg(step_size.to_string())
            .arg("--out-dir").arg(&proof_dir_clone);
        
        // Add arguments
        for arg in args_vec {
            cmd.arg(arg);
        }
        
        cmd.stdout(Stdio::piped())
            .stderr(Stdio::piped());
        
        info!("Executing command: {:?}", cmd);
        cmd.output()
    }).await {
        Ok(Ok(output)) => {
            let duration = start_time.elapsed();
            
            if output.status.success() {
                // Find the generated proof file
                if let Ok(entries) = fs::read_dir(&proof_dir) {
                    for entry in entries.filter_map(Result::ok) {
                        let path = entry.path();
                        if path.extension().and_then(|s| s.to_str()) == Some("bin") {
                            // Calculate metrics
                            let file_size = fs::metadata(&path)
                                .map(|m| m.len() as f64 / 1_048_576.0)
                                .unwrap_or(0.0);
                            
                            let file_hash = calculate_file_hash(&path).await;
                            
                            // Update proof record
                            let mut proofs = state.proof_store.lock().await;
                            if let Some(proof) = proofs.get_mut(&proof_id) {
                                proof.status = ProofStatus::Complete;
                                proof.file_path = Some(path.to_string_lossy().to_string());
                                proof.metrics = ProofMetrics {
                                    generation_time_secs: duration.as_secs_f64(),
                                    file_size_mb: file_size,
                                    file_hash,
                                    peak_memory_mb: None,
                                };
                            }
                            
                            // Save to disk
                            if let Err(e) = save_proofs_to_disk(&*proofs).await {
                                error!("Failed to save proofs to disk: {}", e);
                            }
                            
                            // Send success message
                            let _ = state.tx.send(WsMessage {
                                msg_type: "proof_complete".to_string(),
                                content: format!(
                                    "✅ Proof generated successfully!\n\
                                     • ID: {}\n\
                                     • Time: {:.1}s\n\
                                     • Size: {:.1}MB\n\
                                     • Ready for verification",
                                    &proof_id[..8],
                                    duration.as_secs_f64(),
                                    file_size
                                ),
                                data: Some(json!({ 
                                    "proof_id": proof_id,
                                    "status": "complete",
                                    "metrics": {
                                        "time": duration.as_secs_f64(),
                                        "size_mb": file_size
                                    }
                                })),
                            });
                            
                            return;
                        }
                    }
                }
                
                // No proof file found
                update_proof_failed(&state, &proof_id, "Proof file not found after generation").await;
            } else {
                let error = String::from_utf8_lossy(&output.stderr);
                error!("zkEngine command failed: {}", error);
                update_proof_failed(&state, &proof_id, &format!("zkEngine error: {}", error)).await;
            }
        }
        Ok(Err(e)) => {
            error!("Failed to execute zkEngine: {}", e);
            update_proof_failed(&state, &proof_id, &format!("Execution error: {}", e)).await;
        }
        Err(e) => {
            error!("Task join error: {}", e);
            update_proof_failed(&state, &proof_id, "Internal error").await;
        }
    }
}

async fn update_proof_failed(state: &AppState, proof_id: &str, error: &str) {
    let mut proofs = state.proof_store.lock().await;
    if let Some(proof) = proofs.get_mut(proof_id) {
        proof.status = ProofStatus::Failed(error.to_string());
    }
    
    // Save to disk
    if let Err(e) = save_proofs_to_disk(&*proofs).await {
        error!("Failed to save proofs to disk: {}", e);
    }
    
    let _ = state.tx.send(WsMessage {
        msg_type: "proof_failed".to_string(),
        content: format!("❌ Proof generation failed: {}", error),
        data: Some(json!({ "proof_id": proof_id, "error": error })),
    });
}

async fn calculate_file_hash(path: &Path) -> String {
    match tokio::fs::read(path).await {
        Ok(contents) => {
            let mut hasher = Sha256::new();
            hasher.update(&contents);
            format!("{:x}", hasher.finalize())
        }
        Err(_) => "error".to_string(),
    }
}

async fn verify_proof_command(state: &AppState, proof_id: &str) -> NlResponse {
    let proofs = state.proof_store.lock().await;
    
    // Find proof with matching ID prefix
    let proof = proofs.values().find(|p| p.id.starts_with(proof_id)).cloned();
    drop(proofs);
    
    if let Some(proof) = proof {
        if let ProofStatus::Complete = &proof.status {
            if let Some(proof_path) = &proof.file_path {
                // Send verification started message
                let _ = state.tx.send(WsMessage {
                    msg_type: "verification_start".to_string(),
                    content: format!("🔍 Starting verification of proof {}...", &proof.id[..8]),
                    data: Some(json!({ "proof_id": proof.id })),
                });
                
                let start_time = Instant::now();
                let verification_id = Uuid::new_v4().to_string();
                
                // Find the proof directory and public.json
                let proof_dir = Path::new(proof_path).parent()
                    .ok_or("Invalid proof path")
                    .map_err(|e| {
                        return NlResponse {
                            message: format!("❌ Error: {}", e),
                            data: None,
                        };
                    });
                
                if let Ok(proof_dir) = proof_dir {
                    // Check if proof files exist
                    let proof_dir_str = proof_dir.to_string_lossy().to_string();
                    let proof_file_path = format!("{}/proof.bin", proof_dir_str);
                    let public_file_path = format!("{}/public.json", proof_dir_str);
                    
                    if !Path::new(&proof_file_path).exists() || !Path::new(&public_file_path).exists() {
                        return NlResponse {
                            message: format!("❌ Proof files not found for proof {}. Make sure proof.bin and public.json exist.", &proof.id[..8]),
                            data: None,
                        };
                    }
                    
                    // Run actual zkEngine verify command
                    let zkengine_binary = state.zkengine_binary.clone();
                    let step_size = proof.metadata.step_size;
                    let proof_file_clone = proof_file_path.clone();
                    let public_file_clone = public_file_path.clone();
                    
                    match tokio::task::spawn_blocking(move || {
                        let mut cmd = Command::new(&zkengine_binary);
                        cmd.arg("verify")
                            .arg("--step").arg(step_size.to_string())
                            .arg(&proof_file_clone)
                            .arg(&public_file_clone)
                            .stdout(Stdio::piped())
                            .stderr(Stdio::piped());
                        
                        info!("Executing verify command: {:?}", cmd);
                        cmd.output()
                    }).await {
                        Ok(Ok(output)) => {
                            let duration = start_time.elapsed();
                            let is_valid = output.status.success();
                            let output_str = String::from_utf8_lossy(&output.stdout);
                            
                            // Create verification record
                            let verification = VerificationRecord {
                                id: verification_id,
                                proof_id: proof.id.clone(),
                                timestamp: Utc::now(),
                                is_valid,
                                verification_time_secs: duration.as_secs_f64(),
                                error: if !is_valid {
                                    Some(String::from_utf8_lossy(&output.stderr).to_string())
                                } else {
                                    None
                                },
                            };
                            
                            // Store verification and save to disk
                            {
                                let mut verifications = state.verification_store.lock().await;
                                verifications.push(verification.clone());
                                
                                // Save to disk
                                if let Err(e) = save_verifications_to_disk(&*verifications).await {
                                    error!("Failed to save verifications to disk: {}", e);
                                }
                            }
                            
                            // Send result
                            return NlResponse {
                                message: format!(
                                    "{} Proof Verification Complete!\n\
                                     • Proof ID: {}\n\
                                     • Function: {} with args {:?}\n\
                                     • Proof Size: {:.1}MB\n\
                                     • Verification Time: {:.3}s\n\
                                     • Result: {}\n{}",
                                    if is_valid { "✅" } else { "❌" },
                                    &proof.id[..8],
                                    proof.metadata.function,
                                    proof.metadata.arguments,
                                    proof.metrics.file_size_mb,
                                    duration.as_secs_f64(),
                                    if is_valid { "VALID ✓" } else { "INVALID ✗" },
                                    if !output_str.is_empty() { format!("\nOutput: {}", output_str.trim()) } else { String::new() }
                                ),
                                data: Some(json!({
                                    "type": "verification_complete",
                                    "verification": verification,
                                    "proof": proof,
                                })),
                            };
                        }
                        Ok(Err(e)) => {
                            return NlResponse {
                                message: format!("❌ Failed to execute verification: {}", e),
                                data: None,
                            };
                        }
                        Err(e) => {
                            return NlResponse {
                                message: format!("❌ Verification error: {}", e),
                                data: None,
                            };
                        }
                    }
                }
            }
        }
        
        return NlResponse {
            message: format!("Proof {} is not ready for verification. Status: {:?}", 
                           &proof.id[..8], proof.status),
            data: None,
        };
    }
    
    NlResponse {
        message: "Proof not found. Use 'list all proofs' to see available proofs.".to_string(),
        data: None,
    }
}
